<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="做酷的东西, 成为伟大的工程师，写匪夷所思的代码，然后和每个人成为朋友．"><title>你最了解的 SharedPreference和ContentProvider 知多少？ | 常兴 E 站</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="Bookmark" href="/favicon.ico"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">你最了解的 SharedPreference和ContentProvider 知多少？</h1><a id="logo" href="/.">常兴 E 站</a><p class="description">Action Speak Louder Than Words.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/sitemap.xml"><i class="fa fa-rss"> sitemap</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">你最了解的 SharedPreference和ContentProvider 知多少？</h1><div class="post-meta">Apr 1, 2018<span> | </span><span class="category"><a href="/categories/android/">android</a></span></div><div class="post-content"><p>在技术学习的道路上，往往最常见、用的最多地方，却有着容易忽略的技术细节。某个时间点蓦然回首，才发现最应该了解和掌握的技术基础，却由于缺少总结和记录、或者是因为常态思维固化缺少场景去思考，却显得那么陌生。</p>
<p>这篇文章将从作者自身的角度，去重新认识SharedPreference和ContentProvider这两个控件，并且以后也会在博客中有意识的记录类似的技术细节，防止这些基础的技术细节问题再次被遗忘和忽略。</p>
<a id="more"></a>
<h1 id="SharedPreference和ContentProvider-细节知识加固"><a href="#SharedPreference和ContentProvider-细节知识加固" class="headerlink" title="SharedPreference和ContentProvider 细节知识加固"></a>SharedPreference和ContentProvider 细节知识加固</h1><p>开始前，先来自述下作者对安卓系统这两个控件以往一般的认识。</p>
<p><strong>SharedPreference</strong></p>
<ul>
<li>Android平台轻量级数据存储方式，底层系统封装了xml文件存储，基于key-value键值对数据。</li>
<li>SharedPreference提供了多种读取模式，可支持多进程读取，但是并不保证<em>多进程</em>并发读写安全。</li>
<li>底层xml文件的初始化加载和Edit的apply方法是在子线程中进行。</li>
</ul>
<p><strong>ContentProvider</strong></p>
<ul>
<li>Android平台四大组件之一，数据共享控件，多用于多个进程间的数据传递。</li>
<li>启动要优先于Application的OnCreat方法（查看Application初始化源码得之），尽量不要在App初次启动，（启动进程中）使用多个ContentProvider。</li>
<li>ContentProvider进程间IPC调用，用到了Binder获取文件描述符（<em>FileDescriptor</em>），通过文件描述符实现了高效的共享内存，使得进程间可传递大量数据（Binder接口有1M大小限制）。</li>
</ul>
<h2 id="一、SharedPreference-知识加固"><a href="#一、SharedPreference-知识加固" class="headerlink" title="一、SharedPreference 知识加固"></a>一、SharedPreference 知识加固</h2><p>SharedPreference文件保存在App私有目录中，可以在root手机或者调试模式run-as进入查看。</p>
<p><img src="shared1.png" alt="Shared Path"></p>
<h3 id="1、SharedPreference在多进程并发读取时，数据是不安全，那单进程多个线程并发情况呢？"><a href="#1、SharedPreference在多进程并发读取时，数据是不安全，那单进程多个线程并发情况呢？" class="headerlink" title="1、SharedPreference在多进程并发读取时，数据是不安全，那单进程多个线程并发情况呢？"></a>1、SharedPreference在多进程并发读取时，数据是不安全，那单进程多个线程并发情况呢？</h3><p>平时遇到SharedPreference的数据读取问题，几乎都是多进程并发场景。多进程问题项目中，基本都是封装一层ContentProvider，将数据的读写共享到其他进程，来保证数据的正确性（当然也可以自定义SharedPref的实现类，去保证多进程并发逻辑）。</p>
<p>那单进程情况下SharedPref多线程的并发，却是容易忽略的地方（虽然很久之前，看过SharedPref的部分源码，但是还是忘了系统是有针对并发加锁的）。</p>
<p>其实简单分析下，平时没有遇到单线程的并发问题，也没有针对单线程的SharedPref读写做相关锁操作，理论上应该是线程安全的，那么我们深入源码看看系统到底是如何保证并发安全的～</p>
<p>从ContextImpl开始去获取一个SharedPref实例：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">   <span class="keyword">public</span> SharedPreferences getSharedPreferences(<span class="keyword">File</span> <span class="keyword">file</span>, <span class="keyword">int</span> mode) &#123;</div><div class="line">       checkMode(mode);</div><div class="line">       SharedPreferencesImpl sp; <span class="comment">//真正的系统默认实现类</span></div><div class="line">       <span class="keyword">synchronized</span> (ContextImpl.<span class="keyword">class</span>) &#123;</div><div class="line">           <span class="keyword">final</span> ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</div><div class="line">           sp = cache.get(<span class="keyword">file</span>);</div><div class="line">           <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</div><div class="line">               sp = <span class="keyword">new</span> SharedPreferencesImpl(<span class="keyword">file</span>, mode);</div><div class="line">               cache.put(<span class="keyword">file</span>, sp); <span class="comment">//首次加载缓存</span></div><div class="line">               <span class="keyword">return</span> sp;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> ((mode &amp; Context.MODE_MULTI_PROCESS) != <span class="number">0</span> || <span class="comment">// 多进程模式去写，每次方法被调用时，会ReLoad一次xml文件。</span></div><div class="line">                                                       <span class="comment">// 这种机制在多进程并发严重时，数据是不安全的。</span></div><div class="line">           getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">           <span class="comment">// If somebody else (some other process) changed the prefs</span></div><div class="line">           <span class="comment">// file behind our back, we reload it.  This has been the</span></div><div class="line">           <span class="comment">// historical (if undocumented) behavior.</span></div><div class="line">           sp.startReloadIfChangedUnexpectedly();</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> sp;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>系统中默认的SharedPref实现类是SharedPreferenceImpl，找到这个类相关读写方法，会看到系统已经针对并发加类锁机制。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Editor putLong(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">long</span> value) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            mModified.put(<span class="built_in">key</span>, value);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">long</span> getLong(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">long</span> defValue) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        awaitLoadedLocked();<span class="comment">//注意：这里可能会wait</span></div><div class="line">        Long v = (Long)mMap.<span class="built_in">get</span>(<span class="built_in">key</span>);</div><div class="line">        <span class="keyword">return</span> v != <span class="keyword">null</span> ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，虽然系统默认实现的SharedPreferencesImpl支持的多进程的去写模式，但并不保证数据安全。方法读取时，系统已经帮我们针对并发加类锁机制。</p>
<h3 id="2、Xml文件的初始化加载和Edit的apply方法是在子线程中进行，那么是否意味着，我们可以不用考虑卡UI，去放心的加载大Shared文件和apply的频繁调用？"><a href="#2、Xml文件的初始化加载和Edit的apply方法是在子线程中进行，那么是否意味着，我们可以不用考虑卡UI，去放心的加载大Shared文件和apply的频繁调用？" class="headerlink" title="2、Xml文件的初始化加载和Edit的apply方法是在子线程中进行，那么是否意味着，我们可以不用考虑卡UI，去放心的加载大Shared文件和apply的频繁调用？"></a>2、Xml文件的初始化加载和Edit的apply方法是在子线程中进行，那么是否意味着，我们可以不用考虑卡UI，去放心的加载大Shared文件和apply的频繁调用？</h3><p><strong>A、先来分析Xml的加载问题</strong></p>
<p>还是从源码开始，上文中SharedPreferencesImpl的获取是从下面这段代码开始的：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayMap&lt;String, ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt;&gt; sSharedPrefsCache;<span class="comment">//这里居然是静态的（为了读取速度）</span></div><div class="line"><span class="keyword">synchronized</span> (ContextImpl.<span class="keyword">class</span>) &#123;</div><div class="line">        <span class="keyword">final</span> ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();<span class="comment">//入口</span></div><div class="line">        sp = cache.get(<span class="keyword">file</span>);</div><div class="line">        <span class="keyword">if</span> (sp == <span class="keyword">null</span>) &#123;</div><div class="line">            sp = <span class="keyword">new</span> SharedPreferencesImpl(<span class="keyword">file</span>, mode);<span class="comment">//开始加载</span></div><div class="line">            cache.put(<span class="keyword">file</span>, sp);</div><div class="line">            <span class="keyword">return</span> sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span> ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt; getSharedPreferencesCacheLocked() &#123;</div><div class="line">  <span class="keyword">if</span> (sSharedPrefsCache == <span class="keyword">null</span>) &#123;</div><div class="line">    sSharedPrefsCache = <span class="keyword">new</span> ArrayMap&lt;&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> String packageName = getPackageName();</div><div class="line">  ArrayMap&lt;<span class="keyword">File</span>, SharedPreferencesImpl&gt; packagePrefs = sSharedPrefsCache.get(packageName);</div><div class="line">    <span class="keyword">if</span> (packagePrefs == <span class="keyword">null</span>) &#123;</div><div class="line">    packagePrefs = <span class="keyword">new</span> ArrayMap&lt;&gt;();</div><div class="line">    sSharedPrefsCache.put(packageName, packagePrefs);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> packagePrefs;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里看到，系统为了快速读取已经加载到内存的SharedPref文件，会将读进来的文件保存在一个<strong>静态</strong>的Map中。这样空间换时间，虽然读取速度有了一定优化，但是读到内存的对象，不会被释放。</p>
<p>SharedPreferencesImpl构造器中会开始加载目标file,如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">startLoadFromDisk</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLoaded = <span class="keyword">false</span>;<span class="comment">//是否加载完成的标记</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">new</span> Thread(<span class="string">"SharedPreferencesImpl-load"</span>) &#123;</div><div class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            loadFromDisk();<span class="comment">//	异步加载</span></div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要看mloaded标记，用来标记文件是否已经加载完成，主要用在<em>awaitLoadedLocked()</em>方法中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">awaitLoadedLocked</span><span class="params">()</span> </span>&#123;</div><div class="line">    ～～～</div><div class="line">    ···</div><div class="line">    <span class="keyword">while</span> (!mLoaded) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException unused) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而awaitLoadedLocked()方法会在每次读和保存时调用，以为着在加载过程中，如果主线程有读写操作，依然会卡UI。</p>
<p>So，Xml的加载本身虽然不卡UI，但是读取操作会等待加载过程，依然有可能卡UI的。并且SharedPref尽量分类去保存，避免一次加载很大的无用文件到内存（可能引起GC，依然会卡UI），耗时又耗内存。</p>
<p><strong>B、Apply方法是否会引起卡顿？</strong></p>
<blockquote>
<p>Show me the code</p>
</blockquote>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> MemoryCommitResult mcr = commitToMemory();</div><div class="line">        <span class="keyword">final</span> Runnable awaitCommit = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        mcr.writtenToDiskLatch.await();</div><div class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        QueuedWork.add(awaitCommit);<span class="comment">//关键：新加一个任务到队列</span></div><div class="line"></div><div class="line">        Runnable postWriteRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    awaitCommit.run();</div><div class="line">                    QueuedWork.remove(awaitCommit);<span class="comment">//当保存任务执行后会从队列中移除</span></div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line"></div><div class="line">        SharedPreferencesImpl.<span class="keyword">this</span>.enqueueDiskWrite(mcr, postWriteRunnable);<span class="comment">//在线程中执行</span></div><div class="line"></div><div class="line">        <span class="comment">// Okay to notify the listeners before it's hit disk</span></div><div class="line">        <span class="comment">// because the listeners should always get the same</span></div><div class="line">        <span class="comment">// SharedPreferences instance back, which has the</span></div><div class="line">        <span class="comment">// changes reflected in memory.</span></div><div class="line">        notifyListeners(mcr);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">enqueueDiskWrite</span><span class="params">(<span class="keyword">final</span> MemoryCommitResult mcr,</span></span></div><div class="line">                              <span class="keyword">final</span> Runnable postWriteRunnable) &#123;</div><div class="line">    <span class="keyword">final</span> Runnable writeToDiskRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">synchronized</span> (mWritingToDiskLock) &#123;<span class="comment">//支持并发</span></div><div class="line">                    writeToFile(mcr);<span class="comment">//真正的写入文件</span></div><div class="line">                &#125;</div><div class="line">                <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>) &#123;</div><div class="line">                    mDiskWritesInFlight--;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (postWriteRunnable != <span class="keyword">null</span>) &#123;</div><div class="line">                    postWriteRunnable.run();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFromSyncCommit = (postWriteRunnable == <span class="keyword">null</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Typical #commit() path with fewer allocations, doing a write on</span></div><div class="line">    <span class="comment">// the current thread.</span></div><div class="line">    <span class="keyword">if</span> (isFromSyncCommit) &#123;</div><div class="line">        <span class="keyword">boolean</span> wasEmpty = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">synchronized</span> (SharedPreferencesImpl.<span class="keyword">this</span>) &#123;</div><div class="line">            wasEmpty = mDiskWritesInFlight == <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (wasEmpty) &#123;</div><div class="line">            writeToDiskRunnable.run();</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    QueuedWork.singleThreadExecutor().execute(writeToDiskRunnable);<span class="comment">//单线程池中执行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后只到发现Activity的一段代码（<a href="http://weishu.me/2016/10/13/sharedpreference-advices/" target="_blank" rel="external">思路及代码参考见这里</a>）</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges, <span class="keyword">int</span> seq)</span> </span>&#123;</div><div class="line">....···</div><div class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></div><div class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</div><div class="line">        QueuedWork.waitToFinish();</div><div class="line">    &#125;</div><div class="line">    ···</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">waitToFinish</span><span class="params">()</span> </span>&#123;</div><div class="line">    Runnable toFinish;</div><div class="line">    <span class="keyword">while</span> ((toFinish = sPendingWorkFinishers.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        toFinish.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果Activity在stop时，apply到QueuedWork中任务未执行完，就会在引起主线的等待造成卡顿。</p>
<p>所以，尽量不要频繁的调用apply，可以将多个提交合成一个apply，并且注意规避activity stop时候的SharedPref保存逻辑，避免卡顿。</p>
<h2 id="二、ContentProvider-知识加固"><a href="#二、ContentProvider-知识加固" class="headerlink" title="二、ContentProvider 知识加固"></a>二、ContentProvider 知识加固</h2><h3 id="1、ContentProvider为多进程数据的读取提供类机制，那么单进程下使用ContentProvider-能保证线程并发安全吗？"><a href="#1、ContentProvider为多进程数据的读取提供类机制，那么单进程下使用ContentProvider-能保证线程并发安全吗？" class="headerlink" title="1、ContentProvider为多进程数据的读取提供类机制，那么单进程下使用ContentProvider,能保证线程并发安全吗？"></a>1、ContentProvider为多进程数据的读取提供类机制，那么单进程下使用ContentProvider,能保证线程并发安全吗？</h3><p>平时项目中常用到ContentProvider的地方见的最多的可能就是DB的和SharedPreference的数据封装类，由于Sqlite和SharedPref都是自身可以支持线程并发问题的，并没有注意到ContentProvider自身方法的并发特性。</p>
<p>提高ContentProvider，工程中更多的注意力放在类多进程的交互方式上，而忽略了自身方法调用的细节问题。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">ContentResolver resolver</span> = content.getContentResolver();</div></pre></td></tr></table></figure>
<p>通常，在使用ContentProvider时，会通过以上代码去获取ContentResolver引用，然后调用相关接口方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContentResolver mContentResolver;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="keyword">public</span> <span class="function">ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> mContentResolver;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，接口方法依然在ContextImpl中，可以看到ContentResolver的实现类是ApplicationContentResolver。<br>这里以<em>query</em>方法为例，深入分析下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Cursor query(<span class="keyword">final</span> <span class="meta">@RequiresPermission</span>.Read <span class="meta">@NonNull</span> Uri uri,</div><div class="line">        <span class="meta">@Nullable</span> String[] projection, <span class="meta">@Nullable</span> String selection,</div><div class="line">        <span class="meta">@Nullable</span> String[] selectionArgs, <span class="meta">@Nullable</span> String sortOrder,</div><div class="line">        <span class="meta">@Nullable</span> CancellationSignal cancellationSignal) &#123;</div><div class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);<span class="comment">//抽象方法，ApplicationContentResolver中实现</span></div><div class="line">    <span class="keyword">if</span> (unstableProvider == <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    IContentProvider stableProvider = <span class="literal">null</span>;</div><div class="line">    Cursor qCursor = <span class="literal">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        long startTime = SystemClock.uptimeMillis();</div><div class="line"></div><div class="line">        ICancellationSignal remoteCancellationSignal = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="literal">null</span>) &#123;</div><div class="line">            cancellationSignal.throwIfCanceled();</div><div class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</div><div class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,<span class="comment">//缓存Binder处理</span></div><div class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</div><div class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</div><div class="line">            <span class="comment">// The remote process has died...  but we only hold an unstable</span></div><div class="line">            <span class="comment">// reference though, so we might recover!!!  Let's try!!!!</span></div><div class="line">            <span class="comment">// This is exciting!!1!!1!!!!1</span></div><div class="line">            unstableProviderDied(unstableProvider);<span class="comment">//Provider进程死掉逻辑处理</span></div><div class="line">            stableProvider = acquireProvider(uri);<span class="comment">//抽象方法，ApplicationContentResolver中实现</span></div><div class="line">            <span class="keyword">if</span> (stableProvider == <span class="literal">null</span>) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">            &#125;</div><div class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,<span class="comment">//再次query</span></div><div class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (qCursor == <span class="literal">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> wrapper;</div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">        <span class="comment">// Arbitrary and not worth documenting, as Activity</span></div><div class="line">        <span class="comment">// Manager will kill this process shortly anyway.</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">       <span class="comment">//···</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要跟踪下IContentProvider接口如何在<em>acquireProvider</em>和<em>acquireUnstableProvider</em>中的实现，最终会委托给ActivityThread的<em>acquireProvider</em>方法，如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="function">IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></div><div class="line">    Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable) &#123;</div><div class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);<span class="comment">//缓存中读取</span></div><div class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> provider;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">    holder = ActivityManagerNative.getDefault().getContentProvider(</div><div class="line">            getApplicationThread(), auth, userId, stable);<span class="comment">//缓存没有读到，则跨进程AMS中读取</span></div><div class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</div><div class="line">    Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    holder = installProvider(c, holder, holder.info,</div><div class="line">        <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);<span class="comment">//安装</span></div><div class="line">    <span class="keyword">return</span> holder.provider;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法的最后一个参数stable代表着ContentProvider能否可靠拿到一个进程存活的Provider。首先调用了acquireExistingProvider，去mProviderMap中获取一次接口。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider acquireExistingProvider(</div><div class="line">        Context c, <span class="keyword">String</span> auth, <span class="built_in">int</span> userId, <span class="built_in">boolean</span> stable) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</div><div class="line">        <span class="keyword">final</span> ProviderKey <span class="built_in">key</span> = <span class="keyword">new</span> ProviderKey(auth, userId);</div><div class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.<span class="built_in">get</span>(<span class="built_in">key</span>);<span class="comment">//从缓存中先读取</span></div><div class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IContentProvider provider = pr.mProvider;</div><div class="line">        IBinder jBinder = provider.asBinder();</div><div class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;</div><div class="line">            <span class="comment">// The hosting process of the provider has died; we can't</span></div><div class="line">            <span class="comment">// use this one.</span></div><div class="line">            Log.i(TAG, <span class="string">"Acquiring provider "</span> + auth + <span class="string">" for user "</span> + userId</div><div class="line">                    + <span class="string">": existing object's process dead"</span>);</div><div class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Only increment the ref count if we have one.  If we don't then the</span></div><div class="line">        <span class="comment">// provider is not reference counted and never needs to be released.</span></div><div class="line">        ProviderRefCount prc = mProviderRefCountMap.<span class="built_in">get</span>(jBinder);</div><div class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</div><div class="line">            incProviderRefLocked(prc, stable);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> provider;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>mProviderMap中，这个map的类型是ArrayMap，那么mProviderMap中的数据是哪里的呢？</p>
<p>查下mProvider的put方法，只有<em>installProviderAuthoritiesLocked</em>中调用，并且它是在又是在<strong>installProvider</strong>的调用的，那么重的分析下<em>installProvider</em>方法。</p>
<p>installProvider方法主要会在<em>handleBindApplication</em>和<em>acquireProvider</em>方法中调用，意味着：本进程和AMS获取到的Provider都会调用installProvider最后会放到mProviderMap缓存中，</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">private</span> IActivityManager.ContentProviderHolder installProvider(Context context,</div><div class="line">         IActivityManager.ContentProviderHolder holder, ProviderInfo info,</div><div class="line">         <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable) &#123;</div><div class="line">     ContentProvider localProvider = <span class="keyword">null</span>;</div><div class="line">     IContentProvider provider;</div><div class="line">     <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;</div><div class="line">         <span class="comment">//本地进程provider安装</span></div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">             <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</div><div class="line">             localProvider = (ContentProvider)cl.</div><div class="line">                 loadClass(info.name).newInstance();</div><div class="line">             provider = localProvider.getIContentProvider();</div><div class="line">             <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</div><div class="line">                 Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</div><div class="line">                       info.name + <span class="string">" from sourceDir "</span> +</div><div class="line">                       info.applicationInfo.sourceDir);</div><div class="line">                 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">             &#125;</div><div class="line">            </div><div class="line">             localProvider.attachInfo(c, info);</div><div class="line">         &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</div><div class="line">            </div><div class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">         &#125;</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         provider = holder.provider;</div><div class="line">        	<span class="comment">//跨进程</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     IActivityManager.ContentProviderHolder retHolder;</div><div class="line"></div><div class="line">     synchronized (mProviderMap) &#123;</div><div class="line"><span class="comment">//获取可跨进程的Binder对象</span></div><div class="line">         IBinder jBinder = provider.asBinder();</div><div class="line">         <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</div><div class="line">             ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</div><div class="line">             ProviderClientRecord pr = mLocalProvidersByName.get(cname);</div><div class="line">             <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">                 provider = pr.mProvider;</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</div><div class="line">                 holder.provider = provider;</div><div class="line">                 holder.noReleaseNeeded = <span class="keyword">true</span>;</div><div class="line">                 pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</div><div class="line">                 mLocalProviders.put(jBinder, pr);</div><div class="line">                 mLocalProvidersByName.put(cname, pr);</div><div class="line">             &#125;</div><div class="line">             retHolder = pr.mHolder;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</div><div class="line">             <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</div><div class="line">                 <span class="keyword">if</span> (!noReleaseNeeded) &#123;</div><div class="line">                     incProviderRefLocked(prc, stable);</div><div class="line">                     <span class="keyword">try</span> &#123;</div><div class="line">                         ActivityManagerNative.getDefault().removeContentProvider(</div><div class="line">                                 holder.connection, stable);</div><div class="line">                     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                         <span class="comment">//do nothing content provider object is dead any way</span></div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 ProviderClientRecord <span class="keyword">client</span> = installProviderAuthoritiesLocked(</div><div class="line">                         provider, localProvider, holder);</div><div class="line">                 <span class="keyword">if</span> (noReleaseNeeded) &#123;</div><div class="line">                     prc = <span class="keyword">new</span> ProviderRefCount(holder, <span class="keyword">client</span>, <span class="number">1000</span>, <span class="number">1000</span>);</div><div class="line">                 &#125; <span class="keyword">else</span> &#123;</div><div class="line">                     prc = stable</div><div class="line">                             ? <span class="keyword">new</span> ProviderRefCount(holder, <span class="keyword">client</span>, <span class="number">1</span>, <span class="number">0</span>)</div><div class="line">                             : <span class="keyword">new</span> ProviderRefCount(holder, <span class="keyword">client</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">                 &#125;</div><div class="line">                 mProviderRefCountMap.put(jBinder, prc);</div><div class="line">             &#125;</div><div class="line">             retHolder = prc.holder;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> retHolder;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>分析到这里可以看出，如何Provider是在同一个进程，会通过Binder进口先查下本地对象，然后返回本地Provider实例。</p>
<p>回到起初的query方法，就是直接调用目标对象的query，然后系统对query方法的调用并没有做并发处理，所以可得出结论，ContentProvider的方法调用是非并发安全的。</p>
<h3 id="2、ContentProvider启动时机？"><a href="#2、ContentProvider启动时机？" class="headerlink" title="2、ContentProvider启动时机？"></a>2、ContentProvider启动时机？</h3><p>上文分析中在App进程启动时，通过thread.attach()方法会调用到handleBindApplication，方法内初始化当前进程的application和provider。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> void handleBindApplication(AppBindData <span class="keyword">data</span>) &#123;</div><div class="line"><span class="comment">//···</span></div><div class="line">      <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">          <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></div><div class="line">          <span class="comment">// a restricted environment with the base application class.</span></div><div class="line">          Application app = <span class="keyword">data</span>.info.makeApplication(<span class="keyword">data</span>.restrictedBackupMode, <span class="literal">null</span>);<span class="comment">//注：这里第二个参数是null，意味着Application只会调用attachBaseContext方法</span></div><div class="line">          mInitialApplication = app;</div><div class="line"></div><div class="line">          <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></div><div class="line">          <span class="comment">// app's custom Application class</span></div><div class="line">          <span class="keyword">if</span> (!<span class="keyword">data</span>.restrictedBackupMode) &#123;</div><div class="line">              <span class="keyword">if</span> (!ArrayUtils.isEmpty(<span class="keyword">data</span>.providers)) &#123;</div><div class="line">                  installContentProviders(app, <span class="keyword">data</span>.providers); <span class="comment">//本进程内Provider的启动安装</span></div><div class="line">                  <span class="comment">// For process that contains content providers, we want to</span></div><div class="line">                  <span class="comment">// ensure that the JIT is enabled "at some point".</span></div><div class="line">                  mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">              mInstrumentation.callApplicationOnCreate(app);<span class="comment">// Provider启动后才会继续回调Application的onCreate</span></div><div class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">          &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          StrictMode.setThreadPolicy(savedPolicy);</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此可见，本进程的Provider的安装是在Application初始化调用attact方法后，调用onCreate前启动。所以在App启动时注意规避本进程内的Provider，避免启动耗时。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>技术成长的道路上，不要忽略基础知识的积累，特别是一些细节问题，是不同阶段程序员修炼内功需要坚持的习惯，也是深入技术研究的基础之路。</p>
<hr>
<p>欢迎转载，请标明出处：常兴E站 <a href="http://www.canking.win">canking.win</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.canking.win/2018/04/01/sharedpref/" data-id="cjfhllyau000vn23k5mr661lk" class="article-share-link">分享</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/03/20/mem-oom/" class="pre">Java内存问题 及 LeakCanary 原理分析</a></div><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><span class="donate_txt"><br>		   Enjoy it ? Donate me :  免费分享，共同成长</span><br></div><div id="donate_guide" class="donate_bar center hidden"><a id="donate_weixin" href="http://www.canking.win/images/weixin.jpg" rel="article0" class="fancybox"><img src="http://www.canking.win/images/weixin.jpg" fuck="微信打赏"></a><a id="donate_zhifubao" href="http://www.canking.win/images/zhifubao.jpg" rel="article0" class="fancybox"><img src="http://www.canking.win/images/zhifubao.jpg" fuck="支付宝打赏"></a></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
$('#donate_board').addClass('hidden');
$('#donate_guide').removeClass('hidden');
}</script></div><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-4889224929687616",
enable_page_level_ads: true
});

</script></script><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2136494"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://www.canking.win"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-patterns/">design patterns</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Charles/" style="font-size: 15px;">Charles</a> <a href="/tags/smart-update/" style="font-size: 15px;">smart update</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/float-permission/" style="font-size: 15px;">float permission</a> <a href="/tags/JobQueue/" style="font-size: 15px;">JobQueue</a> <a href="/tags/theme/" style="font-size: 15px;">theme</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/Material-Design/" style="font-size: 15px;">Material Design</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/source-code/" style="font-size: 15px;">source code</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/sharedpref/">你最了解的 SharedPreference和ContentProvider 知多少？</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/mem-oom/">Java内存问题 及 LeakCanary 原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/dy-load/">安卓平台中的动态加载技术分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/mvvm/">Lifecycle+Retrofit+Room完美结合 领略架构之美</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/gradle-android-res/">Gradle插件开发 APK瘦身资源自定义7z压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/minipay/">免sdk实现微信／支付宝转账打赏功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/charles-map/">知识总结之 Charles抓包工具使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/design-ui/">知识总结之 Material Design库常用控件总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/11/plugin-hook/">知识总结之 插件化学习 Hook系统方法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/plugin-activity-loader/">知识总结之 插件化 占坑类Activity实现方式分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.canking.win/fitness" title="健美计步器" target="_blank">健美计步器</a><ul></ul><a href="http://www.canking.win/chargehelper" title="充电助手" target="_blank">充电助手</a><ul></ul><a href="http://sudoku.strikingly.com/" title="爱我数独" target="_blank">爱我数独</a><ul></ul><a href="http://stopwatch.strikingly.com/" title="精确秒表" target="_blank">精确秒表</a><ul></ul><a href="http://www.wandoujia.com/apps/net.canking.gameby" title="色 变" target="_blank">色 变</a><ul></ul><a href="http://canking.strikingly.com/" title="自我简介" target="_blank">自我简介</a><ul></ul><a href="http://cankingapp.github.io/fitness/h5game/index.html" title="H5 Game" target="_blank">H5 Game</a></div><iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=0&isWeibo=1&isFans=1&uid=1894127781&verifier=b6b87527&amp;dpc=1"></iframe></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">常兴 E 站.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> changxing</a> by<a rel="nofollow" target="_blank" href="https://github.com/CankingApp/"> GitHub.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>