<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="做酷的东西, 成为伟大的工程师，写匪夷所思的代码，然后和每个人成为朋友．"><title>Java内存问题思考 | 常兴 E 站</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="shortcut icon" href="/favicon.ico" type="image/x-icon"><link rel="Bookmark" href="/favicon.ico"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java内存问题思考</h1><a id="logo" href="/.">常兴 E 站</a><p class="description">Action Speak Louder Than Words.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/sitemap.xml"><i class="fa fa-rss"> sitemap</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Java内存问题思考</h1><div class="post-meta">Mar 20, 2018<span> | </span><span class="category"><a href="/categories/android/">android</a></span></div><div class="post-content"><p>前些天，有人问到 “开发过程中常见的内存泄漏都有哪些？”，一时脱口而出：静态的对象中（包括单例）持有一个生命周期较短的引用时，或内部类的子代码块对象的生命周期超过了外面代码的生命周期（如非静态内部类，线程），会导致这个短生命周期的对象内存泄漏。总之就是一个对象的生命周期结束（不再使用该对象）后，依然被某些对象所持有该对象强引用的场景就是内存泄漏。</p>
<p>这样回答很明显并不是问答人想要的都有哪些场景，所以这里抽时间整理了下内存相关的知识点，及LeakCanary工具的原理分析。</p>
<h1 id="Java内存问题-及-LeakCanary-原理分析"><a href="#Java内存问题-及-LeakCanary-原理分析" class="headerlink" title="Java内存问题 及 LeakCanary 原理分析"></a>Java内存问题 及 LeakCanary 原理分析</h1><p>在安卓等其他移动平台上，内存问题显得特别重要，想要做到虚拟机内存的高效利用，及内存问题的快速定位，了解下虚拟机内存模块及管理相关知识是很有必要的，这篇文章将从最基础的知识分析，内存问题的产生地方、原因、解决方案等原理。</p>
<h2 id="一、运行时内存区域"><a href="#一、运行时内存区域" class="headerlink" title="一、运行时内存区域"></a>一、运行时内存区域</h2><p><img src="oom1.png" alt="内存区"></p>
<p>这里以Java虚拟机为例，将运行时内存区分为不同的区域，每个区域承担着不同的功能。</p>
<p><em>方法区</em><br>用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError，其中包含常量池和用户存放编译器生成的各种字面量和符号引用。</p>
<p><em>堆</em><br>是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError。</p>
<p><em>虚拟机栈</em><br>描述的是java方法执行的内存模型,每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError、StackOverflowError。</p>
<p><em>本地方法栈</em><br>虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。异常状态StackOverFlowError、OutOfMemoryError。</p>
<p><em>程序计数器</em><br>一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量，这些变量是从主内存中拷贝而来。线程对变量的所有操作（读，写）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。</p>
<p>为了保证内存可见性，常常利用<em>volatile</em>关键子特性来保证变量的可见性（并不能保证并发时原子性）。</p>
<h2 id="二、内存如何回收"><a href="#二、内存如何回收" class="headerlink" title="二、内存如何回收"></a>二、内存如何回收</h2><h3 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h3><p>一个对象从被创建到回收，主要经历阶段有 1：创建阶段(Created)、2： 应用阶段(In Use)、3：不可见阶段(Invisible)、4：不可达阶段(Unreachable)、5：收集阶段(Collected)、6：终结阶段(、Finalized)、7：对象空间重分配阶段(De-allocated)。</p>
<p>内存的分配实在创建阶段，这个阶段要先用类加载器加载目标class，当通过加载器检测后，就开始为新对象分配内存。对象分配内存大小在类加载完成后便可以确定。<br>当初始化完成后，虚拟机还要对对象进行必要的设置，如那个类的实例，如何查找元数据、对象的GC年代等。</p>
<h3 id="内存的回收（GC）"><a href="#内存的回收（GC）" class="headerlink" title="内存的回收（GC）"></a>内存的回收（GC）</h3><p>那些不可能再被任何途径使用的对象，需要被回收，否则内存迟早都会被消耗空。</p>
<p>GC机制主要是通过可达性分析法，通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链时，即GC Roots到对象不可达，则证明此对象是不可达的。</p>
<p>根据<strong>《深入理解Java虚拟机》</strong>书中描述，可作为GC Root的地方如下：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI(Native方法)引用的对象。</li>
</ul>
<p>当一个对象或几个相互引用的对象组没有任何引用链时，会被当成垃圾处理，可以进行回收。</p>
<p>如何一个对象在程序中已经不再使用，但是（强）引用还是会被其他对象持有，则称为内存泄漏。内存泄漏并不会使程序马上异常，但是多处的未处理的内存泄漏则可能导致内存溢出，造成不可预估的后果。</p>
<h3 id="引用的分类"><a href="#引用的分类" class="headerlink" title="引用的分类"></a>引用的分类</h3><p>在JDK1.2之后，为了优化内存的利用及GC的效率，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种。</p>
<p>1、强引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<p>2、软引用，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。SoftReference表示软引用。</p>
<p>3、弱引用，只要有GC，无论当前内存是否足够，都会回收掉<em>只</em>被弱引用关联的对象。WeakReference表示弱引用。</p>
<p>4、虚引用，这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。PhantomReference表示虚引用，需要搭配ReferenceQueue使用，检测对象回收情况。</p>
<h3 id="关于JVM内存管理的一些建议"><a href="#关于JVM内存管理的一些建议" class="headerlink" title="关于JVM内存管理的一些建议"></a>关于JVM内存管理的一些建议</h3><p>1、尽可能的手动将无用对象置为null，加快内存回收。<br>2、可考虑对象池技术生成可重用的对象，较少对象的生成。<br>3、合理利用四种引用。</p>
<h2 id="三、内存泄漏"><a href="#三、内存泄漏" class="headerlink" title="三、内存泄漏"></a>三、内存泄漏</h2><p>持有一个生命周期较短的引用时或内部的子模块对象的生命周期超过了外面模块的生命周期，即本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p>
<p>内存泄漏是造成应用程序OOM的主要原因之一，尤其在像安卓这样的移动平台，难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出Error。</p>
<h3 id="安卓平台常见的内存泄漏"><a href="#安卓平台常见的内存泄漏" class="headerlink" title="安卓平台常见的内存泄漏"></a>安卓平台常见的内存泄漏</h3><p>1、静态成员变量持有外部（短周期临时）对象引用。 如单例类（类内部静态属性）持有一个activity（或其他短周期对象）引用时，导致被持有的对象内存无法释放。</p>
<p>2、内部类。当内部类与外部类生命周期不一致时，就会造成内存泄漏。如非静态内部类创建静态实例、Activity中的Handler或Thread等。</p>
<p>3、资源没有及时关闭。如数据库、IO流、Bitmap、注册的相关服务、webview、动画等。</p>
<p>4、集合内部Item没有置空。</p>
<p>5、方法块内不使用的对象，没有及时置空。</p>
<h2 id="四、如何检测内存泄漏"><a href="#四、如何检测内存泄漏" class="headerlink" title="四、如何检测内存泄漏"></a>四、如何检测内存泄漏</h2><p>Android Studio供了许多对App性能分析的工具，可以方便分析App性能。我们可以使用Memory Monitor和Heap Dump来观察内存的使用情况、使用Allocation Tracker来跟踪内存分配的情况，也可以通过这些工具来找到疑似发生内存泄漏的位置。</p>
<p>堆存储文件（hpof）可以使用DDMS或者Memory Monitor来生成，输出的文件格式为hpof，而MAT（Memory Analysis Tool）就是来分析堆存储文件的。</p>
<p>然而MAT工具分析内存问题并不是一件容易的事情，需要一定的经验区做引用链的分析，需要一定的门槛。<br>随着安卓技术生态的发展，<strong>LeakCanary</strong> 开源项目诞生了，只要几行代码引入目标项目，就可以自动分析hpof文件，把内存泄漏的地方展示出来。</p>
<h2 id="五、LeakCanary原理解析"><a href="#五、LeakCanary原理解析" class="headerlink" title="五、LeakCanary原理解析"></a>五、LeakCanary原理解析</h2><p><img src="oom2.png" alt="LeakCanary"></p>
<blockquote>
<p>A small leak will sink a great ship.</p>
</blockquote>
<p><a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a>内存检测工具是由squar公司开源的著名项目，这里主要分析下源码实现原理。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>主要是在Activity的&amp;<strong>onDestroy</strong>方法中，手动调用 GC，然后利用ReferenceQueue+WeakReference，来判断是否有释放不掉的引用，然后结合dump memory的hpof文件, 用<a href="https://github.com/square/haha" target="_blank" rel="external">HaHa</a>分析出泄漏地方。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>LeakCanary集成很方便，只要几行代码，所以可以从入口跟踪代码，分析原理</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">if</span> (!LeakCanary.isInAnalyzerProcess(WeiboApplication.<span class="keyword">this</span>)) &#123;</div><div class="line">     LeakCanary.install(WeiboApplication.<span class="keyword">this</span>);</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">public</span> static RefWatcher install(Application application) &#123;</div><div class="line">       <span class="keyword">return</span> ((AndroidRefWatcherBuilder)refWatcher(application)</div><div class="line">       .listenerServiceClass(DisplayLeakService.<span class="keyword">class</span>).excludedRefs(AndroidExcludedRefs.createAppDefaults().build()))<span class="comment">//配置监听器及分析数据格式</span></div><div class="line">       .buildAndInstall();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里可看出，LeakCanary会单独开一进程，用来执行分析任务，和监听任务分开处理。</p>
<p>方法<em>install</em>中主要是构造来一个RefWatcher，</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function">RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</div><div class="line">     RefWatcher refWatcher = <span class="keyword">this</span>.build();</div><div class="line">     <span class="keyword">if</span>(refWatcher != RefWatcher.DISABLED) &#123;</div><div class="line">         LeakCanary.enableDisplayLeakActivity(<span class="keyword">this</span>.context);</div><div class="line">         ActivityRefWatcher.install((Application)<span class="keyword">this</span>.context, refWatcher);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> refWatcher;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">install</span><span class="params">(Application application, RefWatcher refWatcher)</span> </span>&#123;</div><div class="line">     (<span class="keyword">new</span> ActivityRefWatcher(application, refWatcher)).watchActivities();</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> ActivityLifecycleCallbacks lifecycleCallbacks = <span class="keyword">new</span> ActivityLifecycleCallbacks() &#123;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityStarted</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityResumed</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;&#125;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123; &#125;</div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">     <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">         ActivityRefWatcher.<span class="keyword">this</span>.onActivityDestroyed(activity);</div><div class="line">     &#125;</div><div class="line"> &#125;;</div><div class="line"> </div><div class="line"> <span class="function"><span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</div><div class="line">     <span class="keyword">this</span>.refWatcher.watch(activity);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>具体监听的原理在于 Application 的<em>registerActivityLifecycleCallbacks</em>方法，该方法可以对应用内所有 Activity 的生命周期做监听, LeakCanary只监听了Destroy方法。</p>
<p>在每个Activity的OnDestroy()方法中都会回调refWatcher.watch()方法，那我们找到的RefWatcher的实现类，看看具体做什么。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> watch(<span class="keyword">Object</span> watchedReference, <span class="keyword">String</span> referenceName) &#123;</div><div class="line">       <span class="keyword">if</span>(<span class="keyword">this</span> != DISABLED) &#123;</div><div class="line">           Preconditions.checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</div><div class="line">           Preconditions.checkNotNull(referenceName, <span class="string">"referenceName"</span>);</div><div class="line">           <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</div><div class="line">           <span class="keyword">String</span> <span class="built_in">key</span> = UUID.randomUUID().toString();<span class="comment">//保证key的唯一性</span></div><div class="line">           <span class="keyword">this</span>.retainedKeys.<span class="built_in">add</span>(<span class="built_in">key</span>);</div><div class="line">           KeyedWeakReference reference = <span class="keyword">new</span> KeyedWeakReference(watchedReference, <span class="built_in">key</span>, referenceName, <span class="keyword">this</span>.queue);</div><div class="line">           <span class="keyword">this</span>.ensureGoneAsync(watchStartNanoTime, reference);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   </div><div class="line"> <span class="keyword">final</span> class KeyedWeakReference extends WeakReference&lt;<span class="keyword">Object</span>&gt; &#123;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> <span class="built_in">key</span>;</div><div class="line">   <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> name;</div><div class="line"></div><div class="line">   KeyedWeakReference(<span class="keyword">Object</span> referent, <span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> name, ReferenceQueue&lt;<span class="keyword">Object</span>&gt; referenceQueue) &#123;<span class="comment">//ReferenceQueue类监听回收情况</span></div><div class="line">       <span class="keyword">super</span>(Preconditions.checkNotNull(referent, <span class="string">"referent"</span>), (ReferenceQueue)Preconditions.checkNotNull(referenceQueue, <span class="string">"referenceQueue"</span>));</div><div class="line">       <span class="keyword">this</span>.<span class="built_in">key</span> = (<span class="keyword">String</span>)Preconditions.checkNotNull(<span class="built_in">key</span>, <span class="string">"key"</span>);</div><div class="line">       <span class="keyword">this</span>.name = (<span class="keyword">String</span>)Preconditions.checkNotNull(name, <span class="string">"name"</span>);</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">void</span> ensureGoneAsync(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference) &#123;</div><div class="line">       <span class="keyword">this</span>.watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</div><div class="line">           <span class="keyword">public</span> Result run() &#123;</div><div class="line">               <span class="keyword">return</span> RefWatcher.<span class="keyword">this</span>.ensureGone(reference, watchStartNanoTime);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p><em>KeyedWeakReference</em>是WeakReference类的子类，用了 KeyedWeakReference(referent,  key,  name, ReferenceQueue<object> )的构造方法，将监听的对象（activity）引用传递进来，并且New出一个ReferenceQueue来监听GC后 的回收情况。</object></p>
<p>以下代码ensureGone()方法就是LeakCanary进行检测回收的核心代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">Result ensureGone(KeyedWeakReference reference, long watchStartNanoTime) &#123;</div><div class="line">    long gcStartNanoTime = System.nanoTime();</div><div class="line">    long watchDurationMs = TimeUnit.NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</div><div class="line">    <span class="keyword">this</span>.removeWeaklyReachableReferences();<span class="comment">//先将引用尝试从队列中poll出来</span></div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.debuggerControl.isDebuggerAttached()) &#123;<span class="comment">//规避调试模式</span></div><div class="line">        <span class="keyword">return</span> Result.RETRY;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.gone(reference)) &#123;<span class="comment">//检测是否已经回收</span></div><div class="line">        <span class="keyword">return</span> Result.DONE;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//如果没有被回收，则手动GC</span></div><div class="line">        <span class="keyword">this</span>.gcTrigger.runGc();<span class="comment">//手动GC方法</span></div><div class="line">        <span class="keyword">this</span>.removeWeaklyReachableReferences();<span class="comment">//再次尝试poll，检测是否被回收</span></div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>.gone(reference)) &#123;</div><div class="line">............<span class="comment">// 还没有被回收，则dump堆信息，调起分析进程进行分析</span></div><div class="line">            long startDumpHeap = System.nanoTime();</div><div class="line">            long gcDurationMs = TimeUnit.NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</div><div class="line">            File heapDumpFile = <span class="keyword">this</span>.heapDumper.dumpHeap();</div><div class="line">            <span class="keyword">if</span>(heapDumpFile == HeapDumper.RETRY_LATER) &#123;</div><div class="line">                <span class="keyword">return</span> Result.RETRY;<span class="comment">//需要重试</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            long heapDumpDurationMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</div><div class="line">            <span class="keyword">this</span>.heapdumpListener.analyze(new HeapDump(heapDumpFile, reference.key, reference.name, <span class="keyword">this</span>.excludedRefs, watchDurationMs, gcDurationMs, heapDumpDurationMs));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> Result.DONE;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> boolean gone(KeyedWeakReference reference) &#123;</div><div class="line">    <span class="keyword">return</span> !<span class="keyword">this</span>.retainedKeys.contains(reference.key);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> void removeWeaklyReachableReferences() &#123;</div><div class="line">    KeyedWeakReference ref;</div><div class="line">    <span class="keyword">while</span>((ref = (KeyedWeakReference)<span class="keyword">this</span>.queue.poll()) != <span class="literal">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.retainedKeys.remove(ref.key);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法ensureGone中通过检测referenceQueue队列中的引用情况，来判断回收情况，通过手动GC来进一步确认回收情况。<br>整个过程肯定是个耗时卡UI的，整个过程会在WatchExecutor中执行的，那WatchExecutor又是在哪里执行的呢？</p>
<p>LeakCanary已经利用Looper机制做了一定优化，利用主线程空闲的时候执行检测任务，这里找到WatchExecutor的实现类，研究下原理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidWatchExecutor</span> <span class="keyword">implements</span> <span class="title">WatchExecutor</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEAK_CANARY_THREAD_NAME = <span class="string">"LeakCanary-Heap-Dump"</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mainHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler backgroundHandler;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> initialDelayMillis;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> maxBackoffFactor;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidWatchExecutor</span><span class="params">(<span class="keyword">long</span> initialDelayMillis)</span> </span>&#123;</div><div class="line">        HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"LeakCanary-Heap-Dump"</span>);</div><div class="line">        handlerThread.start();</div><div class="line">        <span class="keyword">this</span>.backgroundHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper());</div><div class="line">        <span class="keyword">this</span>.initialDelayMillis = initialDelayMillis;</div><div class="line">        <span class="keyword">this</span>.maxBackoffFactor = <span class="number">9223372036854775807L</span> / initialDelayMillis;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Retryable retryable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(Looper.getMainLooper().getThread() == Thread.currentThread()) &#123;</div><div class="line">            <span class="keyword">this</span>.waitForIdle(retryable, <span class="number">0</span>);<span class="comment">//需要在主线程中检测</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">this</span>.postWaitForIdle(retryable, <span class="number">0</span>);<span class="comment">//post到主线程</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postWaitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mainHandler.post(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                AndroidWatchExecutor.<span class="keyword">this</span>.waitForIdle(retryable, failedAttempts);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waitForIdle</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</div><div class="line">        Looper.myQueue().addIdleHandler(<span class="keyword">new</span> IdleHandler() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</div><div class="line">                AndroidWatchExecutor.<span class="keyword">this</span>.postToBackgroundWithDelay(retryable, failedAttempts);<span class="comment">//切换到子线程</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postToBackgroundWithDelay</span><span class="params">(<span class="keyword">final</span> Retryable retryable, <span class="keyword">final</span> <span class="keyword">int</span> failedAttempts)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> exponentialBackoffFactor = (<span class="keyword">long</span>)Math.min(Math.pow(<span class="number">2.0</span>D, (<span class="keyword">double</span>)failedAttempts), (<span class="keyword">double</span>)<span class="keyword">this</span>.maxBackoffFactor);</div><div class="line">        <span class="keyword">long</span> delayMillis = <span class="keyword">this</span>.initialDelayMillis * exponentialBackoffFactor;</div><div class="line">        <span class="keyword">this</span>.backgroundHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                Result result = retryable.run();<span class="comment">//RefWatcher.this.ensureGone(reference, watchStartNanoTime)执行</span></div><div class="line">                <span class="keyword">if</span>(result == Result.RETRY) &#123;</div><div class="line">                    AndroidWatchExecutor.<span class="keyword">this</span>.postWaitForIdle(retryable, failedAttempts + <span class="number">1</span>);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;, delayMillis);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里用到了Handler相关知识，Looper中的MessageQueue有个<em>mIdleHandlers</em>队列，在获取下个要执行的Message时，如果没有发现可执行的下个Msg，就会回调queueIdle()方法。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">Message next() &#123;</div><div class="line">    <span class="built_in">int</span> pendingIdleHandlerCount = <span class="number">-1</span>; <span class="comment">// -1 only during first iteration</span></div><div class="line">    <span class="built_in">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">       		···</div><div class="line">       		···<span class="comment">//省略部分消息查找代码</span></div><div class="line">       		</div><div class="line">       		<span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</div><div class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></div><div class="line">                    nextPollTimeoutMillis = (<span class="built_in">int</span>) Math.<span class="built_in">min</span>(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    ···</div><div class="line">                    </div><div class="line">                    <span class="keyword">return</span> msg;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// No more messages.</span></div><div class="line">                nextPollTimeoutMillis = <span class="number">-1</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">       		</div><div class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></div><div class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></div><div class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></div><div class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</div><div class="line">                pendingIdleHandlerCount = mIdleHandlers.<span class="built_in">size</span>();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></div><div class="line">                mBlocked = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</div><div class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.<span class="built_in">max</span>(pendingIdleHandlerCount, <span class="number">4</span>)];</div><div class="line">            &#125;</div><div class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Run the idle handlers.</span></div><div class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></div><div class="line"></div><div class="line">            <span class="built_in">boolean</span> keep = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                keep = idler.queueIdle();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!keep) &#123;<span class="comment">//返回false，则从队列移除，下次空闲不会调用。</span></div><div class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">                    mIdleHandlers.remove(idler);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></div><div class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></div><div class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></div><div class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的MessageQueue中加入一个IdleHandler，当线程空闲时，就会去调用<em>queueIdle()</em>函数，如果返回值为True，那么后续空闲时会继续的调用此函数，否则不再调用；</p>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>1，用ActivityLifecycleCallbacks接口来检测Activity生命周期<br>2，WeakReference + ReferenceQueue 来监听对象回收情况<br>3，Apolication中可通过processName判断是否是任务执行进程<br>4，MessageQueue中加入一个IdleHandler来得到主线程空闲回调<br>5，LeakCanary检测只针对Activiy里的相关对象。其他类无法使用，还得用MAT原始方法</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>内存相关的问题基本问题回顾了下，发现技术细节越扒越多。想要得到技术的提高，对这些技术细节的掌握是必要的，只有长时间的积累扎实的技术细节基础，才能让自己的技术走的更高。</p>
<p>基础知识对每个工程师发展的不同阶段意义不同，理解的角度和深度也不同。至少自己来看，基础知识是永远值得学习和巩固，来支撑技术的创新实践。</p>
<hr>
<p>欢迎转载，请标明出处：常兴E站 <a href="http://www.canking.win">canking.win</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://www.canking.win/2018/03/20/mem-oom/" data-id="cjf8554ch000kuy3k5xersoxo" class="article-share-link">分享</a><div class="tags"><a href="/tags/android/">android</a></div><div class="post-nav"><a href="/2018/01/07/dy-load/" class="pre">安卓平台中的动态加载技术分析</a></div><div class="post-donate"><div id="donate_board" class="donate_bar center"><a id="btn_donate" href="javascript:;" title="打赏" class="btn_donate"></a><span class="donate_txt"><br>		   Enjoy it ? Donate me :  免费分享，共同成长</span><br></div><div id="donate_guide" class="donate_bar center hidden"><a id="donate_weixin" href="http://www.canking.win/images/weixin.jpg" rel="article0" class="fancybox"><img src="http://www.canking.win/images/weixin.jpg" fuck="微信打赏"></a><a id="donate_zhifubao" href="http://www.canking.win/images/zhifubao.jpg" rel="article0" class="fancybox"><img src="http://www.canking.win/images/zhifubao.jpg" fuck="支付宝打赏"></a></div><script type="text/javascript">document.getElementById('btn_donate').onclick = function(){
$('#donate_board').addClass('hidden');
$('#donate_guide').removeClass('hidden');
}</script></div><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"><script>(adsbygoogle = window.adsbygoogle || []).push({
google_ad_client: "ca-pub-4889224929687616",
enable_page_level_ads: true
});

</script></script><div id="uyan_frame"></div><script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2136494"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://www.canking.win"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Tool/">Tool</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a><span class="category-list-count">19</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/design-patterns/">design patterns</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/gradle/">gradle</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/node/">node</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Plugin/" style="font-size: 15px;">Plugin</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/smart-update/" style="font-size: 15px;">smart update</a> <a href="/tags/JobQueue/" style="font-size: 15px;">JobQueue</a> <a href="/tags/float-permission/" style="font-size: 15px;">float permission</a> <a href="/tags/android/" style="font-size: 15px;">android</a> <a href="/tags/theme/" style="font-size: 15px;">theme</a> <a href="/tags/Charles/" style="font-size: 15px;">Charles</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Material-Design/" style="font-size: 15px;">Material Design</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/ffmpeg/" style="font-size: 15px;">ffmpeg</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/source-code/" style="font-size: 15px;">source code</a> <a href="/tags/node/" style="font-size: 15px;">node</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/20/mem-oom/">Java内存问题思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/07/dy-load/">安卓平台中的动态加载技术分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/09/mvvm/">Lifecycle+Retrofit+Room完美结合 领略架构之美</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/19/gradle-android-res/">Gradle插件开发 APK瘦身资源自定义7z压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/21/minipay/">免sdk实现微信／支付宝转账打赏功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/03/charles-map/">知识总结之 Charles抓包工具使用总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/29/design-ui/">知识总结之 Material Design库常用控件总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/11/plugin-hook/">知识总结之 插件化学习 Hook系统方法分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/plugin-activity-loader/">知识总结之 插件化 占坑类Activity实现方式分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/01/binder/">知识总结 插件化学习 Binder机制原理</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.canking.win/fitness" title="健美计步器" target="_blank">健美计步器</a><ul></ul><a href="http://www.canking.win/chargehelper" title="充电助手" target="_blank">充电助手</a><ul></ul><a href="http://sudoku.strikingly.com/" title="爱我数独" target="_blank">爱我数独</a><ul></ul><a href="http://stopwatch.strikingly.com/" title="精确秒表" target="_blank">精确秒表</a><ul></ul><a href="http://www.wandoujia.com/apps/net.canking.gameby" title="色 变" target="_blank">色 变</a><ul></ul><a href="http://canking.strikingly.com/" title="自我简介" target="_blank">自我简介</a><ul></ul><a href="http://cankingapp.github.io/fitness/h5game/index.html" title="H5 Game" target="_blank">H5 Game</a></div><iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=1&amp;isTitle=1&amp;noborder=0&isWeibo=1&isFans=1&uid=1894127781&verifier=b6b87527&amp;dpc=1"></iframe></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">常兴 E 站.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> changxing</a> by<a rel="nofollow" target="_blank" href="https://github.com/CankingApp/"> GitHub.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>